Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> many_class_decl
Rule 2     many_class_decl -> class_decl many_class_decl
Rule 3     many_class_decl -> empty
Rule 4     class_decl -> CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY
Rule 5     class_decl -> CLASS ID LCURLY class_body_decl_list RCURLY
Rule 6     class_body_decl_list -> class_body_decl many_class_body_decl
Rule 7     many_class_body_decl -> class_body_decl many_class_body_decl
Rule 8     many_class_body_decl -> empty
Rule 9     class_body_decl -> field_decl
Rule 10    class_body_decl -> method_decl
Rule 11    class_body_decl -> constructor_decl
Rule 12    field_decl -> modifier var_decl
Rule 13    modifier -> PUBLIC STATIC
Rule 14    modifier -> PRIVATE STATIC
Rule 15    modifier -> STATIC
Rule 16    modifier -> PUBLIC
Rule 17    modifier -> PRIVATE
Rule 18    modifier -> empty
Rule 19    var_decl -> type variables SEMICOLON
Rule 20    type -> INT
Rule 21    type -> FLOAT
Rule 22    type -> BOOLEAN
Rule 23    type -> VOID
Rule 24    type -> NULL
Rule 25    type -> ID
Rule 26    variables -> variable comma_var
Rule 27    comma_var -> COMMA variable comma_var
Rule 28    comma_var -> empty
Rule 29    variable -> ID
Rule 30    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 31    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 32    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 33    formals -> formal_param comma_formal
Rule 34    formals -> empty
Rule 35    comma_formal -> COMMA formal_param comma_formal
Rule 36    comma_formal -> empty
Rule 37    formal_param -> type variable
Rule 38    block -> LCURLY many_stmts RCURLY
Rule 39    many_stmts -> stmt many_stmts
Rule 40    many_stmts -> empty
Rule 41    stmt -> IF LPAREN expr RPAREN stmt
Rule 42    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 43    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 44    stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
Rule 45    stmt -> RETURN return_val SEMICOLON
Rule 46    stmt -> stmt_expr SEMICOLON
Rule 47    stmt -> BREAK SEMICOLON
Rule 48    stmt -> CONTINUE SEMICOLON
Rule 49    stmt -> block
Rule 50    stmt -> var_decl
Rule 51    stmt -> SEMICOLON
Rule 52    for_cond1 -> stmt_expr
Rule 53    for_cond1 -> empty
Rule 54    for_cond2 -> expr
Rule 55    for_cond2 -> empty
Rule 56    for_cond3 -> stmt_expr
Rule 57    for_cond3 -> empty
Rule 58    return_val -> expr
Rule 59    return_val -> empty
Rule 60    literal -> INT_CONST
Rule 61    literal -> FLOAT_CONST
Rule 62    literal -> STRING_CONST
Rule 63    literal -> NULL
Rule 64    literal -> TRUE
Rule 65    literal -> FALSE
Rule 66    primary -> literal
Rule 67    primary -> THIS
Rule 68    primary -> SUPER
Rule 69    primary -> LPAREN expr RPAREN
Rule 70    primary -> NEW ID LPAREN arguments RPAREN
Rule 71    primary -> lhs
Rule 72    primary -> method_invocation
Rule 73    arguments -> expr many_comma_expr
Rule 74    arguments -> empty
Rule 75    many_comma_expr -> COMMA expr many_comma_expr
Rule 76    many_comma_expr -> empty
Rule 77    lhs -> field_access
Rule 78    field_access -> primary PERIOD ID
Rule 79    field_access -> ID
Rule 80    method_invocation -> field_access LPAREN arguments RPAREN
Rule 81    expr -> primary
Rule 82    expr -> assign
Rule 83    expr -> expr PLUS expr
Rule 84    expr -> expr MINUS expr
Rule 85    expr -> expr TIMES expr
Rule 86    expr -> expr DIVIDE expr
Rule 87    expr -> expr AND expr
Rule 88    expr -> expr OR expr
Rule 89    expr -> expr EEQUALS expr
Rule 90    expr -> expr NEQUALS expr
Rule 91    expr -> expr LESS expr
Rule 92    expr -> expr GREATER expr
Rule 93    expr -> expr LEQUALS expr
Rule 94    expr -> expr GEQUALS expr
Rule 95    expr -> PLUS expr
Rule 96    expr -> MINUS expr
Rule 97    expr -> NOT expr
Rule 98    assign -> lhs EQUALS expr
Rule 99    assign -> lhs PLUSPLUS
Rule 100   assign -> PLUSPLUS lhs
Rule 101   assign -> lhs MINUSMINUS
Rule 102   assign -> MINUSMINUS lhs
Rule 103   stmt_expr -> assign
Rule 104   stmt_expr -> method_invocation
Rule 105   empty -> <empty>

Terminals, with rules where they appear

AND                  : 87
BOOLEAN              : 22
BREAK                : 47
CLASS                : 4 5
COMMA                : 27 35 75
COMMENT              : 
CONTINUE             : 48
DIVIDE               : 86
DO                   : 
EEQUALS              : 89
ELSE                 : 42
EQUALS               : 98
EXTENDS              : 4
FALSE                : 65
FLOAT                : 21
FLOAT_CONST          : 61
FOR                  : 44
GEQUALS              : 94
GREATER              : 92
ID                   : 4 4 5 25 29 30 31 32 70 78 79
IF                   : 41 42
INT                  : 20
INT_CONST            : 60
LCURLY               : 4 5 38
LEQUALS              : 93
LESS                 : 91
LPAREN               : 30 31 32 41 42 43 44 69 70 80
MINUS                : 84 96
MINUSMINUS           : 101 102
NEQUALS              : 90
NEW                  : 70
NOT                  : 97
NULL                 : 24 63
OR                   : 88
PERIOD               : 78
PLUS                 : 83 95
PLUSPLUS             : 99 100
PRIVATE              : 14 17
PUBLIC               : 13 16
RCURLY               : 4 5 38
RETURN               : 45
RPAREN               : 30 31 32 41 42 43 44 69 70 80
SEMICOLON            : 19 44 44 45 46 47 48 51
STATIC               : 13 14 15
STRING_CONST         : 62
SUPER                : 68
THIS                 : 67
TIMES                : 85
TRUE                 : 64
VOID                 : 23 31
WHILE                : 43
error                : 

Nonterminals, with rules where they appear

arguments            : 70 80
assign               : 82 103
block                : 30 31 32 49
class_body_decl      : 6 7
class_body_decl_list : 4 5
class_decl           : 2
comma_formal         : 33 35
comma_var            : 26 27
constructor_decl     : 11
empty                : 3 8 18 28 34 36 40 53 55 57 59 74 76
expr                 : 41 42 43 54 58 69 73 75 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 96 97 98
field_access         : 77 80
field_decl           : 9
for_cond1            : 44
for_cond2            : 44
for_cond3            : 44
formal_param         : 33 35
formals              : 30 31 32
lhs                  : 71 98 99 100 101 102
literal              : 66
many_class_body_decl : 6 7
many_class_decl      : 1 2
many_comma_expr      : 73 75
many_stmts           : 38 39
method_decl          : 10
method_invocation    : 72 104
modifier             : 12 30 31 32
primary              : 78 81
program              : 0
return_val           : 45
stmt                 : 39 41 42 42 43 44
stmt_expr            : 46 52 56
type                 : 19 30 37
var_decl             : 12 50
variable             : 26 27 37
variables            : 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . many_class_decl
    (2) many_class_decl -> . class_decl many_class_decl
    (3) many_class_decl -> . empty
    (4) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY
    (5) class_decl -> . CLASS ID LCURLY class_body_decl_list RCURLY
    (105) empty -> .

    CLASS           shift and go to state 5
    $end            reduce using rule 105 (empty -> .)

    program                        shift and go to state 1
    many_class_decl                shift and go to state 2
    class_decl                     shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> many_class_decl .

    $end            reduce using rule 1 (program -> many_class_decl .)


state 3

    (2) many_class_decl -> class_decl . many_class_decl
    (2) many_class_decl -> . class_decl many_class_decl
    (3) many_class_decl -> . empty
    (4) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY
    (5) class_decl -> . CLASS ID LCURLY class_body_decl_list RCURLY
    (105) empty -> .

    CLASS           shift and go to state 5
    $end            reduce using rule 105 (empty -> .)

    class_decl                     shift and go to state 3
    many_class_decl                shift and go to state 6
    empty                          shift and go to state 4

state 4

    (3) many_class_decl -> empty .

    $end            reduce using rule 3 (many_class_decl -> empty .)


state 5

    (4) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body_decl_list RCURLY
    (5) class_decl -> CLASS . ID LCURLY class_body_decl_list RCURLY

    ID              shift and go to state 7


state 6

    (2) many_class_decl -> class_decl many_class_decl .

    $end            reduce using rule 2 (many_class_decl -> class_decl many_class_decl .)


state 7

    (4) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body_decl_list RCURLY
    (5) class_decl -> CLASS ID . LCURLY class_body_decl_list RCURLY

    EXTENDS         shift and go to state 8
    LCURLY          shift and go to state 9


state 8

    (4) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body_decl_list RCURLY

    ID              shift and go to state 10


state 9

    (5) class_decl -> CLASS ID LCURLY . class_body_decl_list RCURLY
    (6) class_body_decl_list -> . class_body_decl many_class_body_decl
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (12) field_decl -> . modifier var_decl
    (30) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (31) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . empty
    (105) empty -> .

    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 18
    VOID            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)
    NULL            reduce using rule 105 (empty -> .)

    class_body_decl_list           shift and go to state 11
    class_body_decl                shift and go to state 12
    field_decl                     shift and go to state 13
    method_decl                    shift and go to state 14
    constructor_decl               shift and go to state 15
    modifier                       shift and go to state 16
    empty                          shift and go to state 20

state 10

    (4) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body_decl_list RCURLY

    LCURLY          shift and go to state 21


state 11

    (5) class_decl -> CLASS ID LCURLY class_body_decl_list . RCURLY

    RCURLY          shift and go to state 22


state 12

    (6) class_body_decl_list -> class_body_decl . many_class_body_decl
    (7) many_class_body_decl -> . class_body_decl many_class_body_decl
    (8) many_class_body_decl -> . empty
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (105) empty -> .
    (12) field_decl -> . modifier var_decl
    (30) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (31) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . empty

    RCURLY          reduce using rule 105 (empty -> .)
    VOID            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)
    NULL            reduce using rule 105 (empty -> .)
    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 18

    class_body_decl                shift and go to state 23
    many_class_body_decl           shift and go to state 24
    empty                          shift and go to state 25
    field_decl                     shift and go to state 13
    method_decl                    shift and go to state 14
    constructor_decl               shift and go to state 15
    modifier                       shift and go to state 16

state 13

    (9) class_body_decl -> field_decl .

    PUBLIC          reduce using rule 9 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> field_decl .)
    VOID            reduce using rule 9 (class_body_decl -> field_decl .)
    ID              reduce using rule 9 (class_body_decl -> field_decl .)
    INT             reduce using rule 9 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> field_decl .)
    NULL            reduce using rule 9 (class_body_decl -> field_decl .)
    RCURLY          reduce using rule 9 (class_body_decl -> field_decl .)


state 14

    (10) class_body_decl -> method_decl .

    PUBLIC          reduce using rule 10 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> method_decl .)
    VOID            reduce using rule 10 (class_body_decl -> method_decl .)
    ID              reduce using rule 10 (class_body_decl -> method_decl .)
    INT             reduce using rule 10 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> method_decl .)
    NULL            reduce using rule 10 (class_body_decl -> method_decl .)
    RCURLY          reduce using rule 10 (class_body_decl -> method_decl .)


state 15

    (11) class_body_decl -> constructor_decl .

    PUBLIC          reduce using rule 11 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 11 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 11 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 11 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> constructor_decl .)
    NULL            reduce using rule 11 (class_body_decl -> constructor_decl .)
    RCURLY          reduce using rule 11 (class_body_decl -> constructor_decl .)


state 16

    (12) field_decl -> modifier . var_decl
    (30) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (31) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (32) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (19) var_decl -> . type variables SEMICOLON
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID

    VOID            shift and go to state 29
    ID              shift and go to state 28
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    NULL            shift and go to state 33

    var_decl                       shift and go to state 26
    type                           shift and go to state 27

state 17

    (13) modifier -> PUBLIC . STATIC
    (16) modifier -> PUBLIC .

    STATIC          shift and go to state 34
    VOID            reduce using rule 16 (modifier -> PUBLIC .)
    ID              reduce using rule 16 (modifier -> PUBLIC .)
    INT             reduce using rule 16 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 16 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 16 (modifier -> PUBLIC .)
    NULL            reduce using rule 16 (modifier -> PUBLIC .)


state 18

    (15) modifier -> STATIC .

    VOID            reduce using rule 15 (modifier -> STATIC .)
    ID              reduce using rule 15 (modifier -> STATIC .)
    INT             reduce using rule 15 (modifier -> STATIC .)
    FLOAT           reduce using rule 15 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> STATIC .)
    NULL            reduce using rule 15 (modifier -> STATIC .)


state 19

    (14) modifier -> PRIVATE . STATIC
    (17) modifier -> PRIVATE .

    STATIC          shift and go to state 35
    VOID            reduce using rule 17 (modifier -> PRIVATE .)
    ID              reduce using rule 17 (modifier -> PRIVATE .)
    INT             reduce using rule 17 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 17 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 17 (modifier -> PRIVATE .)
    NULL            reduce using rule 17 (modifier -> PRIVATE .)


state 20

    (18) modifier -> empty .

    VOID            reduce using rule 18 (modifier -> empty .)
    ID              reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)
    NULL            reduce using rule 18 (modifier -> empty .)


state 21

    (4) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body_decl_list RCURLY
    (6) class_body_decl_list -> . class_body_decl many_class_body_decl
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (12) field_decl -> . modifier var_decl
    (30) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (31) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . empty
    (105) empty -> .

    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 18
    VOID            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)
    NULL            reduce using rule 105 (empty -> .)

    class_body_decl_list           shift and go to state 36
    class_body_decl                shift and go to state 12
    field_decl                     shift and go to state 13
    method_decl                    shift and go to state 14
    constructor_decl               shift and go to state 15
    modifier                       shift and go to state 16
    empty                          shift and go to state 20

state 22

    (5) class_decl -> CLASS ID LCURLY class_body_decl_list RCURLY .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID LCURLY class_body_decl_list RCURLY .)
    $end            reduce using rule 5 (class_decl -> CLASS ID LCURLY class_body_decl_list RCURLY .)


state 23

    (7) many_class_body_decl -> class_body_decl . many_class_body_decl
    (7) many_class_body_decl -> . class_body_decl many_class_body_decl
    (8) many_class_body_decl -> . empty
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (105) empty -> .
    (12) field_decl -> . modifier var_decl
    (30) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (31) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (32) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC
    (17) modifier -> . PRIVATE
    (18) modifier -> . empty

    RCURLY          reduce using rule 105 (empty -> .)
    VOID            reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)
    NULL            reduce using rule 105 (empty -> .)
    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 18

    class_body_decl                shift and go to state 23
    many_class_body_decl           shift and go to state 37
    empty                          shift and go to state 25
    field_decl                     shift and go to state 13
    method_decl                    shift and go to state 14
    constructor_decl               shift and go to state 15
    modifier                       shift and go to state 16

state 24

    (6) class_body_decl_list -> class_body_decl many_class_body_decl .

    RCURLY          reduce using rule 6 (class_body_decl_list -> class_body_decl many_class_body_decl .)


state 25

    (8) many_class_body_decl -> empty .
    (18) modifier -> empty .

    RCURLY          reduce using rule 8 (many_class_body_decl -> empty .)
    VOID            reduce using rule 18 (modifier -> empty .)
    ID              reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)
    NULL            reduce using rule 18 (modifier -> empty .)


state 26

    (12) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 12 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 12 (field_decl -> modifier var_decl .)
    ID              reduce using rule 12 (field_decl -> modifier var_decl .)
    INT             reduce using rule 12 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 12 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 12 (field_decl -> modifier var_decl .)
    NULL            reduce using rule 12 (field_decl -> modifier var_decl .)
    RCURLY          reduce using rule 12 (field_decl -> modifier var_decl .)


state 27

    (30) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (19) var_decl -> type . variables SEMICOLON
    (26) variables -> . variable comma_var
    (29) variable -> . ID

    ID              shift and go to state 38

    variables                      shift and go to state 39
    variable                       shift and go to state 40

state 28

    (32) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (25) type -> ID .

    LPAREN          shift and go to state 41
    ID              reduce using rule 25 (type -> ID .)


state 29

    (31) method_decl -> modifier VOID . ID LPAREN formals RPAREN block
    (23) type -> VOID .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 42

  ! ID              [ reduce using rule 23 (type -> VOID .) ]


state 30

    (20) type -> INT .

    ID              reduce using rule 20 (type -> INT .)


state 31

    (21) type -> FLOAT .

    ID              reduce using rule 21 (type -> FLOAT .)


state 32

    (22) type -> BOOLEAN .

    ID              reduce using rule 22 (type -> BOOLEAN .)


state 33

    (24) type -> NULL .

    ID              reduce using rule 24 (type -> NULL .)


state 34

    (13) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 13 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC STATIC .)
    NULL            reduce using rule 13 (modifier -> PUBLIC STATIC .)


state 35

    (14) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 14 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 14 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 14 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 14 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PRIVATE STATIC .)
    NULL            reduce using rule 14 (modifier -> PRIVATE STATIC .)


state 36

    (4) class_decl -> CLASS ID EXTENDS ID LCURLY class_body_decl_list . RCURLY

    RCURLY          shift and go to state 43


state 37

    (7) many_class_body_decl -> class_body_decl many_class_body_decl .

    RCURLY          reduce using rule 7 (many_class_body_decl -> class_body_decl many_class_body_decl .)


state 38

    (30) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (29) variable -> ID .

    LPAREN          shift and go to state 44
    COMMA           reduce using rule 29 (variable -> ID .)
    SEMICOLON       reduce using rule 29 (variable -> ID .)


state 39

    (19) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 45


state 40

    (26) variables -> variable . comma_var
    (27) comma_var -> . COMMA variable comma_var
    (28) comma_var -> . empty
    (105) empty -> .

    COMMA           shift and go to state 47
    SEMICOLON       reduce using rule 105 (empty -> .)

    comma_var                      shift and go to state 46
    empty                          shift and go to state 48

state 41

    (32) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (33) formals -> . formal_param comma_formal
    (34) formals -> . empty
    (37) formal_param -> . type variable
    (105) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID

    RPAREN          reduce using rule 105 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 33
    ID              shift and go to state 49

    formals                        shift and go to state 50
    formal_param                   shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 53

state 42

    (31) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 55


state 43

    (4) class_decl -> CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY .)
    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body_decl_list RCURLY .)


state 44

    (30) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (33) formals -> . formal_param comma_formal
    (34) formals -> . empty
    (37) formal_param -> . type variable
    (105) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID

    RPAREN          reduce using rule 105 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 33
    ID              shift and go to state 49

    type                           shift and go to state 53
    formals                        shift and go to state 56
    formal_param                   shift and go to state 51
    empty                          shift and go to state 52

state 45

    (19) var_decl -> type variables SEMICOLON .

    PUBLIC          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    RCURLY          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    PLUSPLUS        reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    MINUSMINUS      reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 19 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 19 (var_decl -> type variables SEMICOLON .)


state 46

    (26) variables -> variable comma_var .

    SEMICOLON       reduce using rule 26 (variables -> variable comma_var .)


state 47

    (27) comma_var -> COMMA . variable comma_var
    (29) variable -> . ID

    ID              shift and go to state 58

    variable                       shift and go to state 57

state 48

    (28) comma_var -> empty .

    SEMICOLON       reduce using rule 28 (comma_var -> empty .)


state 49

    (25) type -> ID .

    ID              reduce using rule 25 (type -> ID .)


state 50

    (32) constructor_decl -> modifier ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 59


state 51

    (33) formals -> formal_param . comma_formal
    (35) comma_formal -> . COMMA formal_param comma_formal
    (36) comma_formal -> . empty
    (105) empty -> .

    COMMA           shift and go to state 61
    RPAREN          reduce using rule 105 (empty -> .)

    comma_formal                   shift and go to state 60
    empty                          shift and go to state 62

state 52

    (34) formals -> empty .

    RPAREN          reduce using rule 34 (formals -> empty .)


state 53

    (37) formal_param -> type . variable
    (29) variable -> . ID

    ID              shift and go to state 58

    variable                       shift and go to state 63

state 54

    (23) type -> VOID .

    ID              reduce using rule 23 (type -> VOID .)


state 55

    (31) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (33) formals -> . formal_param comma_formal
    (34) formals -> . empty
    (37) formal_param -> . type variable
    (105) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID

    RPAREN          reduce using rule 105 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 33
    ID              shift and go to state 49

    formals                        shift and go to state 64
    formal_param                   shift and go to state 51
    empty                          shift and go to state 52
    type                           shift and go to state 53

state 56

    (30) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 65


state 57

    (27) comma_var -> COMMA variable . comma_var
    (27) comma_var -> . COMMA variable comma_var
    (28) comma_var -> . empty
    (105) empty -> .

    COMMA           shift and go to state 47
    SEMICOLON       reduce using rule 105 (empty -> .)

    comma_var                      shift and go to state 66
    empty                          shift and go to state 48

state 58

    (29) variable -> ID .

    COMMA           reduce using rule 29 (variable -> ID .)
    SEMICOLON       reduce using rule 29 (variable -> ID .)
    RPAREN          reduce using rule 29 (variable -> ID .)


state 59

    (32) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (38) block -> . LCURLY many_stmts RCURLY

    LCURLY          shift and go to state 68

    block                          shift and go to state 67

state 60

    (33) formals -> formal_param comma_formal .

    RPAREN          reduce using rule 33 (formals -> formal_param comma_formal .)


state 61

    (35) comma_formal -> COMMA . formal_param comma_formal
    (37) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 33
    ID              shift and go to state 49

    formal_param                   shift and go to state 69
    type                           shift and go to state 53

state 62

    (36) comma_formal -> empty .

    RPAREN          reduce using rule 36 (comma_formal -> empty .)


state 63

    (37) formal_param -> type variable .

    COMMA           reduce using rule 37 (formal_param -> type variable .)
    RPAREN          reduce using rule 37 (formal_param -> type variable .)


state 64

    (31) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 70


state 65

    (30) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (38) block -> . LCURLY many_stmts RCURLY

    LCURLY          shift and go to state 68

    block                          shift and go to state 71

state 66

    (27) comma_var -> COMMA variable comma_var .

    SEMICOLON       reduce using rule 27 (comma_var -> COMMA variable comma_var .)


state 67

    (32) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    NULL            reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 32 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 68

    (38) block -> LCURLY . many_stmts RCURLY
    (39) many_stmts -> . stmt many_stmts
    (40) many_stmts -> . empty
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (105) empty -> .
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    RCURLY          reduce using rule 105 (empty -> .)
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    many_stmts                     shift and go to state 72
    stmt                           shift and go to state 73
    empty                          shift and go to state 74
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 69

    (35) comma_formal -> COMMA formal_param . comma_formal
    (35) comma_formal -> . COMMA formal_param comma_formal
    (36) comma_formal -> . empty
    (105) empty -> .

    COMMA           shift and go to state 61
    RPAREN          reduce using rule 105 (empty -> .)

    comma_formal                   shift and go to state 105
    empty                          shift and go to state 62

state 70

    (31) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (38) block -> . LCURLY many_stmts RCURLY

    LCURLY          shift and go to state 68

    block                          shift and go to state 106

state 71

    (30) method_decl -> modifier type ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    NULL            reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 30 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 72

    (38) block -> LCURLY many_stmts . RCURLY

    RCURLY          shift and go to state 107


state 73

    (39) many_stmts -> stmt . many_stmts
    (39) many_stmts -> . stmt many_stmts
    (40) many_stmts -> . empty
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (105) empty -> .
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    RCURLY          reduce using rule 105 (empty -> .)
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    stmt                           shift and go to state 73
    many_stmts                     shift and go to state 108
    empty                          shift and go to state 74
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 74

    (40) many_stmts -> empty .

    RCURLY          reduce using rule 40 (many_stmts -> empty .)


state 75

    (41) stmt -> IF . LPAREN expr RPAREN stmt
    (42) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 109


state 76

    (69) primary -> LPAREN . expr RPAREN
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 110
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 77

    (43) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 121


state 78

    (44) stmt -> FOR . LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt

    LPAREN          shift and go to state 122


state 79

    (51) stmt -> SEMICOLON .

    IF              reduce using rule 51 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 51 (stmt -> SEMICOLON .)
    PLUSPLUS        reduce using rule 51 (stmt -> SEMICOLON .)
    MINUSMINUS      reduce using rule 51 (stmt -> SEMICOLON .)
    INT             reduce using rule 51 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> SEMICOLON .)
    VOID            reduce using rule 51 (stmt -> SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> SEMICOLON .)
    ID              reduce using rule 51 (stmt -> SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 51 (stmt -> SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 51 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 51 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 51 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> SEMICOLON .)
    RCURLY          reduce using rule 51 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> SEMICOLON .)


state 80

    (45) stmt -> RETURN . return_val SEMICOLON
    (58) return_val -> . expr
    (59) return_val -> . empty
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (105) empty -> .
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    SEMICOLON       reduce using rule 105 (empty -> .)
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    return_val                     shift and go to state 123
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 81

    (46) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 126


state 82

    (47) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 127


state 83

    (48) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 128


state 84

    (49) stmt -> block .

    IF              reduce using rule 49 (stmt -> block .)
    WHILE           reduce using rule 49 (stmt -> block .)
    FOR             reduce using rule 49 (stmt -> block .)
    RETURN          reduce using rule 49 (stmt -> block .)
    BREAK           reduce using rule 49 (stmt -> block .)
    CONTINUE        reduce using rule 49 (stmt -> block .)
    SEMICOLON       reduce using rule 49 (stmt -> block .)
    LCURLY          reduce using rule 49 (stmt -> block .)
    PLUSPLUS        reduce using rule 49 (stmt -> block .)
    MINUSMINUS      reduce using rule 49 (stmt -> block .)
    INT             reduce using rule 49 (stmt -> block .)
    FLOAT           reduce using rule 49 (stmt -> block .)
    BOOLEAN         reduce using rule 49 (stmt -> block .)
    VOID            reduce using rule 49 (stmt -> block .)
    NULL            reduce using rule 49 (stmt -> block .)
    ID              reduce using rule 49 (stmt -> block .)
    THIS            reduce using rule 49 (stmt -> block .)
    SUPER           reduce using rule 49 (stmt -> block .)
    LPAREN          reduce using rule 49 (stmt -> block .)
    NEW             reduce using rule 49 (stmt -> block .)
    INT_CONST       reduce using rule 49 (stmt -> block .)
    FLOAT_CONST     reduce using rule 49 (stmt -> block .)
    STRING_CONST    reduce using rule 49 (stmt -> block .)
    TRUE            reduce using rule 49 (stmt -> block .)
    FALSE           reduce using rule 49 (stmt -> block .)
    RCURLY          reduce using rule 49 (stmt -> block .)
    ELSE            reduce using rule 49 (stmt -> block .)


state 85

    (50) stmt -> var_decl .

    IF              reduce using rule 50 (stmt -> var_decl .)
    WHILE           reduce using rule 50 (stmt -> var_decl .)
    FOR             reduce using rule 50 (stmt -> var_decl .)
    RETURN          reduce using rule 50 (stmt -> var_decl .)
    BREAK           reduce using rule 50 (stmt -> var_decl .)
    CONTINUE        reduce using rule 50 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 50 (stmt -> var_decl .)
    LCURLY          reduce using rule 50 (stmt -> var_decl .)
    PLUSPLUS        reduce using rule 50 (stmt -> var_decl .)
    MINUSMINUS      reduce using rule 50 (stmt -> var_decl .)
    INT             reduce using rule 50 (stmt -> var_decl .)
    FLOAT           reduce using rule 50 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 50 (stmt -> var_decl .)
    VOID            reduce using rule 50 (stmt -> var_decl .)
    NULL            reduce using rule 50 (stmt -> var_decl .)
    ID              reduce using rule 50 (stmt -> var_decl .)
    THIS            reduce using rule 50 (stmt -> var_decl .)
    SUPER           reduce using rule 50 (stmt -> var_decl .)
    LPAREN          reduce using rule 50 (stmt -> var_decl .)
    NEW             reduce using rule 50 (stmt -> var_decl .)
    INT_CONST       reduce using rule 50 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 50 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 50 (stmt -> var_decl .)
    TRUE            reduce using rule 50 (stmt -> var_decl .)
    FALSE           reduce using rule 50 (stmt -> var_decl .)
    RCURLY          reduce using rule 50 (stmt -> var_decl .)
    ELSE            reduce using rule 50 (stmt -> var_decl .)


state 86

    (103) stmt_expr -> assign .

    SEMICOLON       reduce using rule 103 (stmt_expr -> assign .)
    RPAREN          reduce using rule 103 (stmt_expr -> assign .)


state 87

    (104) stmt_expr -> method_invocation .
    (72) primary -> method_invocation .

    SEMICOLON       reduce using rule 104 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 104 (stmt_expr -> method_invocation .)
    PERIOD          reduce using rule 72 (primary -> method_invocation .)


state 88

    (19) var_decl -> type . variables SEMICOLON
    (26) variables -> . variable comma_var
    (29) variable -> . ID

    ID              shift and go to state 58

    variables                      shift and go to state 39
    variable                       shift and go to state 40

state 89

    (98) assign -> lhs . EQUALS expr
    (99) assign -> lhs . PLUSPLUS
    (101) assign -> lhs . MINUSMINUS
    (71) primary -> lhs .

    EQUALS          shift and go to state 129
    PLUSPLUS        shift and go to state 130
    MINUSMINUS      shift and go to state 131
    PERIOD          reduce using rule 71 (primary -> lhs .)


state 90

    (100) assign -> PLUSPLUS . lhs
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (80) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 116
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    lhs                            shift and go to state 132
    field_access                   shift and go to state 120
    primary                        shift and go to state 95
    literal                        shift and go to state 96
    method_invocation              shift and go to state 118

state 91

    (102) assign -> MINUSMINUS . lhs
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (80) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 116
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    lhs                            shift and go to state 133
    field_access                   shift and go to state 120
    primary                        shift and go to state 95
    literal                        shift and go to state 96
    method_invocation              shift and go to state 118

state 92

    (80) method_invocation -> field_access . LPAREN arguments RPAREN
    (77) lhs -> field_access .

    LPAREN          shift and go to state 134
    EQUALS          reduce using rule 77 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 77 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 77 (lhs -> field_access .)
    PERIOD          reduce using rule 77 (lhs -> field_access .)


state 93

    (24) type -> NULL .
    (63) literal -> NULL .

    ID              reduce using rule 24 (type -> NULL .)
    PERIOD          reduce using rule 63 (literal -> NULL .)


state 94

    (25) type -> ID .
    (79) field_access -> ID .

    ID              reduce using rule 25 (type -> ID .)
    LPAREN          reduce using rule 79 (field_access -> ID .)
    EQUALS          reduce using rule 79 (field_access -> ID .)
    PLUSPLUS        reduce using rule 79 (field_access -> ID .)
    MINUSMINUS      reduce using rule 79 (field_access -> ID .)
    PERIOD          reduce using rule 79 (field_access -> ID .)


state 95

    (78) field_access -> primary . PERIOD ID

    PERIOD          shift and go to state 135


state 96

    (66) primary -> literal .

    PERIOD          reduce using rule 66 (primary -> literal .)
    RPAREN          reduce using rule 66 (primary -> literal .)
    PLUS            reduce using rule 66 (primary -> literal .)
    MINUS           reduce using rule 66 (primary -> literal .)
    TIMES           reduce using rule 66 (primary -> literal .)
    DIVIDE          reduce using rule 66 (primary -> literal .)
    AND             reduce using rule 66 (primary -> literal .)
    OR              reduce using rule 66 (primary -> literal .)
    EEQUALS         reduce using rule 66 (primary -> literal .)
    NEQUALS         reduce using rule 66 (primary -> literal .)
    LESS            reduce using rule 66 (primary -> literal .)
    GREATER         reduce using rule 66 (primary -> literal .)
    LEQUALS         reduce using rule 66 (primary -> literal .)
    GEQUALS         reduce using rule 66 (primary -> literal .)
    SEMICOLON       reduce using rule 66 (primary -> literal .)
    COMMA           reduce using rule 66 (primary -> literal .)


state 97

    (67) primary -> THIS .

    PERIOD          reduce using rule 67 (primary -> THIS .)
    RPAREN          reduce using rule 67 (primary -> THIS .)
    PLUS            reduce using rule 67 (primary -> THIS .)
    MINUS           reduce using rule 67 (primary -> THIS .)
    TIMES           reduce using rule 67 (primary -> THIS .)
    DIVIDE          reduce using rule 67 (primary -> THIS .)
    AND             reduce using rule 67 (primary -> THIS .)
    OR              reduce using rule 67 (primary -> THIS .)
    EEQUALS         reduce using rule 67 (primary -> THIS .)
    NEQUALS         reduce using rule 67 (primary -> THIS .)
    LESS            reduce using rule 67 (primary -> THIS .)
    GREATER         reduce using rule 67 (primary -> THIS .)
    LEQUALS         reduce using rule 67 (primary -> THIS .)
    GEQUALS         reduce using rule 67 (primary -> THIS .)
    SEMICOLON       reduce using rule 67 (primary -> THIS .)
    COMMA           reduce using rule 67 (primary -> THIS .)


state 98

    (68) primary -> SUPER .

    PERIOD          reduce using rule 68 (primary -> SUPER .)
    RPAREN          reduce using rule 68 (primary -> SUPER .)
    PLUS            reduce using rule 68 (primary -> SUPER .)
    MINUS           reduce using rule 68 (primary -> SUPER .)
    TIMES           reduce using rule 68 (primary -> SUPER .)
    DIVIDE          reduce using rule 68 (primary -> SUPER .)
    AND             reduce using rule 68 (primary -> SUPER .)
    OR              reduce using rule 68 (primary -> SUPER .)
    EEQUALS         reduce using rule 68 (primary -> SUPER .)
    NEQUALS         reduce using rule 68 (primary -> SUPER .)
    LESS            reduce using rule 68 (primary -> SUPER .)
    GREATER         reduce using rule 68 (primary -> SUPER .)
    LEQUALS         reduce using rule 68 (primary -> SUPER .)
    GEQUALS         reduce using rule 68 (primary -> SUPER .)
    SEMICOLON       reduce using rule 68 (primary -> SUPER .)
    COMMA           reduce using rule 68 (primary -> SUPER .)


state 99

    (70) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 136


state 100

    (60) literal -> INT_CONST .

    PERIOD          reduce using rule 60 (literal -> INT_CONST .)
    RPAREN          reduce using rule 60 (literal -> INT_CONST .)
    PLUS            reduce using rule 60 (literal -> INT_CONST .)
    MINUS           reduce using rule 60 (literal -> INT_CONST .)
    TIMES           reduce using rule 60 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 60 (literal -> INT_CONST .)
    AND             reduce using rule 60 (literal -> INT_CONST .)
    OR              reduce using rule 60 (literal -> INT_CONST .)
    EEQUALS         reduce using rule 60 (literal -> INT_CONST .)
    NEQUALS         reduce using rule 60 (literal -> INT_CONST .)
    LESS            reduce using rule 60 (literal -> INT_CONST .)
    GREATER         reduce using rule 60 (literal -> INT_CONST .)
    LEQUALS         reduce using rule 60 (literal -> INT_CONST .)
    GEQUALS         reduce using rule 60 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 60 (literal -> INT_CONST .)
    COMMA           reduce using rule 60 (literal -> INT_CONST .)


state 101

    (61) literal -> FLOAT_CONST .

    PERIOD          reduce using rule 61 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 61 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 61 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 61 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 61 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 61 (literal -> FLOAT_CONST .)
    AND             reduce using rule 61 (literal -> FLOAT_CONST .)
    OR              reduce using rule 61 (literal -> FLOAT_CONST .)
    EEQUALS         reduce using rule 61 (literal -> FLOAT_CONST .)
    NEQUALS         reduce using rule 61 (literal -> FLOAT_CONST .)
    LESS            reduce using rule 61 (literal -> FLOAT_CONST .)
    GREATER         reduce using rule 61 (literal -> FLOAT_CONST .)
    LEQUALS         reduce using rule 61 (literal -> FLOAT_CONST .)
    GEQUALS         reduce using rule 61 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 61 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 61 (literal -> FLOAT_CONST .)


state 102

    (62) literal -> STRING_CONST .

    PERIOD          reduce using rule 62 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 62 (literal -> STRING_CONST .)
    PLUS            reduce using rule 62 (literal -> STRING_CONST .)
    MINUS           reduce using rule 62 (literal -> STRING_CONST .)
    TIMES           reduce using rule 62 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 62 (literal -> STRING_CONST .)
    AND             reduce using rule 62 (literal -> STRING_CONST .)
    OR              reduce using rule 62 (literal -> STRING_CONST .)
    EEQUALS         reduce using rule 62 (literal -> STRING_CONST .)
    NEQUALS         reduce using rule 62 (literal -> STRING_CONST .)
    LESS            reduce using rule 62 (literal -> STRING_CONST .)
    GREATER         reduce using rule 62 (literal -> STRING_CONST .)
    LEQUALS         reduce using rule 62 (literal -> STRING_CONST .)
    GEQUALS         reduce using rule 62 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 62 (literal -> STRING_CONST .)
    COMMA           reduce using rule 62 (literal -> STRING_CONST .)


state 103

    (64) literal -> TRUE .

    PERIOD          reduce using rule 64 (literal -> TRUE .)
    RPAREN          reduce using rule 64 (literal -> TRUE .)
    PLUS            reduce using rule 64 (literal -> TRUE .)
    MINUS           reduce using rule 64 (literal -> TRUE .)
    TIMES           reduce using rule 64 (literal -> TRUE .)
    DIVIDE          reduce using rule 64 (literal -> TRUE .)
    AND             reduce using rule 64 (literal -> TRUE .)
    OR              reduce using rule 64 (literal -> TRUE .)
    EEQUALS         reduce using rule 64 (literal -> TRUE .)
    NEQUALS         reduce using rule 64 (literal -> TRUE .)
    LESS            reduce using rule 64 (literal -> TRUE .)
    GREATER         reduce using rule 64 (literal -> TRUE .)
    LEQUALS         reduce using rule 64 (literal -> TRUE .)
    GEQUALS         reduce using rule 64 (literal -> TRUE .)
    SEMICOLON       reduce using rule 64 (literal -> TRUE .)
    COMMA           reduce using rule 64 (literal -> TRUE .)


state 104

    (65) literal -> FALSE .

    PERIOD          reduce using rule 65 (literal -> FALSE .)
    RPAREN          reduce using rule 65 (literal -> FALSE .)
    PLUS            reduce using rule 65 (literal -> FALSE .)
    MINUS           reduce using rule 65 (literal -> FALSE .)
    TIMES           reduce using rule 65 (literal -> FALSE .)
    DIVIDE          reduce using rule 65 (literal -> FALSE .)
    AND             reduce using rule 65 (literal -> FALSE .)
    OR              reduce using rule 65 (literal -> FALSE .)
    EEQUALS         reduce using rule 65 (literal -> FALSE .)
    NEQUALS         reduce using rule 65 (literal -> FALSE .)
    LESS            reduce using rule 65 (literal -> FALSE .)
    GREATER         reduce using rule 65 (literal -> FALSE .)
    LEQUALS         reduce using rule 65 (literal -> FALSE .)
    GEQUALS         reduce using rule 65 (literal -> FALSE .)
    SEMICOLON       reduce using rule 65 (literal -> FALSE .)
    COMMA           reduce using rule 65 (literal -> FALSE .)


state 105

    (35) comma_formal -> COMMA formal_param comma_formal .

    RPAREN          reduce using rule 35 (comma_formal -> COMMA formal_param comma_formal .)


state 106

    (31) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    NULL            reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    RCURLY          reduce using rule 31 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 107

    (38) block -> LCURLY many_stmts RCURLY .

    PUBLIC          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    PRIVATE         reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    STATIC          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    VOID            reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    ID              reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    INT             reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    FLOAT           reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    BOOLEAN         reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    NULL            reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    RCURLY          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    IF              reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    WHILE           reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    FOR             reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    RETURN          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    BREAK           reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    CONTINUE        reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    SEMICOLON       reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    LCURLY          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    PLUSPLUS        reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    MINUSMINUS      reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    THIS            reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    SUPER           reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    LPAREN          reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    NEW             reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    INT_CONST       reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    FLOAT_CONST     reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    STRING_CONST    reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    TRUE            reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    FALSE           reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)
    ELSE            reduce using rule 38 (block -> LCURLY many_stmts RCURLY .)


state 108

    (39) many_stmts -> stmt many_stmts .

    RCURLY          reduce using rule 39 (many_stmts -> stmt many_stmts .)


state 109

    (41) stmt -> IF LPAREN . expr RPAREN stmt
    (42) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 137
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 110

    (69) primary -> LPAREN expr . RPAREN
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          shift and go to state 138
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150


state 111

    (81) expr -> primary .
    (78) field_access -> primary . PERIOD ID

    RPAREN          reduce using rule 81 (expr -> primary .)
    PLUS            reduce using rule 81 (expr -> primary .)
    MINUS           reduce using rule 81 (expr -> primary .)
    TIMES           reduce using rule 81 (expr -> primary .)
    DIVIDE          reduce using rule 81 (expr -> primary .)
    AND             reduce using rule 81 (expr -> primary .)
    OR              reduce using rule 81 (expr -> primary .)
    EEQUALS         reduce using rule 81 (expr -> primary .)
    NEQUALS         reduce using rule 81 (expr -> primary .)
    LESS            reduce using rule 81 (expr -> primary .)
    GREATER         reduce using rule 81 (expr -> primary .)
    LEQUALS         reduce using rule 81 (expr -> primary .)
    GEQUALS         reduce using rule 81 (expr -> primary .)
    SEMICOLON       reduce using rule 81 (expr -> primary .)
    COMMA           reduce using rule 81 (expr -> primary .)
    PERIOD          shift and go to state 135


state 112

    (82) expr -> assign .

    RPAREN          reduce using rule 82 (expr -> assign .)
    PLUS            reduce using rule 82 (expr -> assign .)
    MINUS           reduce using rule 82 (expr -> assign .)
    TIMES           reduce using rule 82 (expr -> assign .)
    DIVIDE          reduce using rule 82 (expr -> assign .)
    AND             reduce using rule 82 (expr -> assign .)
    OR              reduce using rule 82 (expr -> assign .)
    EEQUALS         reduce using rule 82 (expr -> assign .)
    NEQUALS         reduce using rule 82 (expr -> assign .)
    LESS            reduce using rule 82 (expr -> assign .)
    GREATER         reduce using rule 82 (expr -> assign .)
    LEQUALS         reduce using rule 82 (expr -> assign .)
    GEQUALS         reduce using rule 82 (expr -> assign .)
    SEMICOLON       reduce using rule 82 (expr -> assign .)
    COMMA           reduce using rule 82 (expr -> assign .)


state 113

    (95) expr -> PLUS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 151
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 114

    (96) expr -> MINUS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 152
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 115

    (97) expr -> NOT . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 153
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 116

    (79) field_access -> ID .

    LPAREN          reduce using rule 79 (field_access -> ID .)
    EQUALS          reduce using rule 79 (field_access -> ID .)
    PLUSPLUS        reduce using rule 79 (field_access -> ID .)
    MINUSMINUS      reduce using rule 79 (field_access -> ID .)
    PERIOD          reduce using rule 79 (field_access -> ID .)
    RPAREN          reduce using rule 79 (field_access -> ID .)
    PLUS            reduce using rule 79 (field_access -> ID .)
    MINUS           reduce using rule 79 (field_access -> ID .)
    TIMES           reduce using rule 79 (field_access -> ID .)
    DIVIDE          reduce using rule 79 (field_access -> ID .)
    AND             reduce using rule 79 (field_access -> ID .)
    OR              reduce using rule 79 (field_access -> ID .)
    EEQUALS         reduce using rule 79 (field_access -> ID .)
    NEQUALS         reduce using rule 79 (field_access -> ID .)
    LESS            reduce using rule 79 (field_access -> ID .)
    GREATER         reduce using rule 79 (field_access -> ID .)
    LEQUALS         reduce using rule 79 (field_access -> ID .)
    GEQUALS         reduce using rule 79 (field_access -> ID .)
    SEMICOLON       reduce using rule 79 (field_access -> ID .)
    COMMA           reduce using rule 79 (field_access -> ID .)


state 117

    (71) primary -> lhs .
    (98) assign -> lhs . EQUALS expr
    (99) assign -> lhs . PLUSPLUS
    (101) assign -> lhs . MINUSMINUS

    PERIOD          reduce using rule 71 (primary -> lhs .)
    RPAREN          reduce using rule 71 (primary -> lhs .)
    PLUS            reduce using rule 71 (primary -> lhs .)
    MINUS           reduce using rule 71 (primary -> lhs .)
    TIMES           reduce using rule 71 (primary -> lhs .)
    DIVIDE          reduce using rule 71 (primary -> lhs .)
    AND             reduce using rule 71 (primary -> lhs .)
    OR              reduce using rule 71 (primary -> lhs .)
    EEQUALS         reduce using rule 71 (primary -> lhs .)
    NEQUALS         reduce using rule 71 (primary -> lhs .)
    LESS            reduce using rule 71 (primary -> lhs .)
    GREATER         reduce using rule 71 (primary -> lhs .)
    LEQUALS         reduce using rule 71 (primary -> lhs .)
    GEQUALS         reduce using rule 71 (primary -> lhs .)
    SEMICOLON       reduce using rule 71 (primary -> lhs .)
    COMMA           reduce using rule 71 (primary -> lhs .)
    EQUALS          shift and go to state 129
    PLUSPLUS        shift and go to state 130
    MINUSMINUS      shift and go to state 131


state 118

    (72) primary -> method_invocation .

    PERIOD          reduce using rule 72 (primary -> method_invocation .)
    RPAREN          reduce using rule 72 (primary -> method_invocation .)
    PLUS            reduce using rule 72 (primary -> method_invocation .)
    MINUS           reduce using rule 72 (primary -> method_invocation .)
    TIMES           reduce using rule 72 (primary -> method_invocation .)
    DIVIDE          reduce using rule 72 (primary -> method_invocation .)
    AND             reduce using rule 72 (primary -> method_invocation .)
    OR              reduce using rule 72 (primary -> method_invocation .)
    EEQUALS         reduce using rule 72 (primary -> method_invocation .)
    NEQUALS         reduce using rule 72 (primary -> method_invocation .)
    LESS            reduce using rule 72 (primary -> method_invocation .)
    GREATER         reduce using rule 72 (primary -> method_invocation .)
    LEQUALS         reduce using rule 72 (primary -> method_invocation .)
    GEQUALS         reduce using rule 72 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 72 (primary -> method_invocation .)
    COMMA           reduce using rule 72 (primary -> method_invocation .)


state 119

    (63) literal -> NULL .

    PERIOD          reduce using rule 63 (literal -> NULL .)
    RPAREN          reduce using rule 63 (literal -> NULL .)
    PLUS            reduce using rule 63 (literal -> NULL .)
    MINUS           reduce using rule 63 (literal -> NULL .)
    TIMES           reduce using rule 63 (literal -> NULL .)
    DIVIDE          reduce using rule 63 (literal -> NULL .)
    AND             reduce using rule 63 (literal -> NULL .)
    OR              reduce using rule 63 (literal -> NULL .)
    EEQUALS         reduce using rule 63 (literal -> NULL .)
    NEQUALS         reduce using rule 63 (literal -> NULL .)
    LESS            reduce using rule 63 (literal -> NULL .)
    GREATER         reduce using rule 63 (literal -> NULL .)
    LEQUALS         reduce using rule 63 (literal -> NULL .)
    GEQUALS         reduce using rule 63 (literal -> NULL .)
    SEMICOLON       reduce using rule 63 (literal -> NULL .)
    COMMA           reduce using rule 63 (literal -> NULL .)


state 120

    (77) lhs -> field_access .
    (80) method_invocation -> field_access . LPAREN arguments RPAREN

    EQUALS          reduce using rule 77 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 77 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 77 (lhs -> field_access .)
    PERIOD          reduce using rule 77 (lhs -> field_access .)
    RPAREN          reduce using rule 77 (lhs -> field_access .)
    PLUS            reduce using rule 77 (lhs -> field_access .)
    MINUS           reduce using rule 77 (lhs -> field_access .)
    TIMES           reduce using rule 77 (lhs -> field_access .)
    DIVIDE          reduce using rule 77 (lhs -> field_access .)
    AND             reduce using rule 77 (lhs -> field_access .)
    OR              reduce using rule 77 (lhs -> field_access .)
    EEQUALS         reduce using rule 77 (lhs -> field_access .)
    NEQUALS         reduce using rule 77 (lhs -> field_access .)
    LESS            reduce using rule 77 (lhs -> field_access .)
    GREATER         reduce using rule 77 (lhs -> field_access .)
    LEQUALS         reduce using rule 77 (lhs -> field_access .)
    GEQUALS         reduce using rule 77 (lhs -> field_access .)
    SEMICOLON       reduce using rule 77 (lhs -> field_access .)
    COMMA           reduce using rule 77 (lhs -> field_access .)
    LPAREN          shift and go to state 134


state 121

    (43) stmt -> WHILE LPAREN . expr RPAREN stmt
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 154
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 122

    (44) stmt -> FOR LPAREN . for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (52) for_cond1 -> . stmt_expr
    (53) for_cond1 -> . empty
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (105) empty -> .
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    SEMICOLON       reduce using rule 105 (empty -> .)
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    ID              shift and go to state 116
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    for_cond1                      shift and go to state 155
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 123

    (45) stmt -> RETURN return_val . SEMICOLON

    SEMICOLON       shift and go to state 158


state 124

    (58) return_val -> expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    SEMICOLON       reduce using rule 58 (return_val -> expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150


state 125

    (59) return_val -> empty .

    SEMICOLON       reduce using rule 59 (return_val -> empty .)


state 126

    (46) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    LCURLY          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    PLUSPLUS        reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    MINUSMINUS      reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    VOID            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    RCURLY          reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> stmt_expr SEMICOLON .)


state 127

    (47) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    PLUSPLUS        reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    MINUSMINUS      reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    RCURLY          reduce using rule 47 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> BREAK SEMICOLON .)


state 128

    (48) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    PLUSPLUS        reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    MINUSMINUS      reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    RCURLY          reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 48 (stmt -> CONTINUE SEMICOLON .)


state 129

    (98) assign -> lhs EQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    lhs                            shift and go to state 117
    expr                           shift and go to state 159
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 130

    (99) assign -> lhs PLUSPLUS .

    SEMICOLON       reduce using rule 99 (assign -> lhs PLUSPLUS .)
    RPAREN          reduce using rule 99 (assign -> lhs PLUSPLUS .)
    PLUS            reduce using rule 99 (assign -> lhs PLUSPLUS .)
    MINUS           reduce using rule 99 (assign -> lhs PLUSPLUS .)
    TIMES           reduce using rule 99 (assign -> lhs PLUSPLUS .)
    DIVIDE          reduce using rule 99 (assign -> lhs PLUSPLUS .)
    AND             reduce using rule 99 (assign -> lhs PLUSPLUS .)
    OR              reduce using rule 99 (assign -> lhs PLUSPLUS .)
    EEQUALS         reduce using rule 99 (assign -> lhs PLUSPLUS .)
    NEQUALS         reduce using rule 99 (assign -> lhs PLUSPLUS .)
    LESS            reduce using rule 99 (assign -> lhs PLUSPLUS .)
    GREATER         reduce using rule 99 (assign -> lhs PLUSPLUS .)
    LEQUALS         reduce using rule 99 (assign -> lhs PLUSPLUS .)
    GEQUALS         reduce using rule 99 (assign -> lhs PLUSPLUS .)
    COMMA           reduce using rule 99 (assign -> lhs PLUSPLUS .)


state 131

    (101) assign -> lhs MINUSMINUS .

    SEMICOLON       reduce using rule 101 (assign -> lhs MINUSMINUS .)
    RPAREN          reduce using rule 101 (assign -> lhs MINUSMINUS .)
    PLUS            reduce using rule 101 (assign -> lhs MINUSMINUS .)
    MINUS           reduce using rule 101 (assign -> lhs MINUSMINUS .)
    TIMES           reduce using rule 101 (assign -> lhs MINUSMINUS .)
    DIVIDE          reduce using rule 101 (assign -> lhs MINUSMINUS .)
    AND             reduce using rule 101 (assign -> lhs MINUSMINUS .)
    OR              reduce using rule 101 (assign -> lhs MINUSMINUS .)
    EEQUALS         reduce using rule 101 (assign -> lhs MINUSMINUS .)
    NEQUALS         reduce using rule 101 (assign -> lhs MINUSMINUS .)
    LESS            reduce using rule 101 (assign -> lhs MINUSMINUS .)
    GREATER         reduce using rule 101 (assign -> lhs MINUSMINUS .)
    LEQUALS         reduce using rule 101 (assign -> lhs MINUSMINUS .)
    GEQUALS         reduce using rule 101 (assign -> lhs MINUSMINUS .)
    COMMA           reduce using rule 101 (assign -> lhs MINUSMINUS .)


state 132

    (100) assign -> PLUSPLUS lhs .
    (71) primary -> lhs .

    SEMICOLON       reduce using rule 100 (assign -> PLUSPLUS lhs .)
    RPAREN          reduce using rule 100 (assign -> PLUSPLUS lhs .)
    PLUS            reduce using rule 100 (assign -> PLUSPLUS lhs .)
    MINUS           reduce using rule 100 (assign -> PLUSPLUS lhs .)
    TIMES           reduce using rule 100 (assign -> PLUSPLUS lhs .)
    DIVIDE          reduce using rule 100 (assign -> PLUSPLUS lhs .)
    AND             reduce using rule 100 (assign -> PLUSPLUS lhs .)
    OR              reduce using rule 100 (assign -> PLUSPLUS lhs .)
    EEQUALS         reduce using rule 100 (assign -> PLUSPLUS lhs .)
    NEQUALS         reduce using rule 100 (assign -> PLUSPLUS lhs .)
    LESS            reduce using rule 100 (assign -> PLUSPLUS lhs .)
    GREATER         reduce using rule 100 (assign -> PLUSPLUS lhs .)
    LEQUALS         reduce using rule 100 (assign -> PLUSPLUS lhs .)
    GEQUALS         reduce using rule 100 (assign -> PLUSPLUS lhs .)
    COMMA           reduce using rule 100 (assign -> PLUSPLUS lhs .)
    PERIOD          reduce using rule 71 (primary -> lhs .)


state 133

    (102) assign -> MINUSMINUS lhs .
    (71) primary -> lhs .

    SEMICOLON       reduce using rule 102 (assign -> MINUSMINUS lhs .)
    RPAREN          reduce using rule 102 (assign -> MINUSMINUS lhs .)
    PLUS            reduce using rule 102 (assign -> MINUSMINUS lhs .)
    MINUS           reduce using rule 102 (assign -> MINUSMINUS lhs .)
    TIMES           reduce using rule 102 (assign -> MINUSMINUS lhs .)
    DIVIDE          reduce using rule 102 (assign -> MINUSMINUS lhs .)
    AND             reduce using rule 102 (assign -> MINUSMINUS lhs .)
    OR              reduce using rule 102 (assign -> MINUSMINUS lhs .)
    EEQUALS         reduce using rule 102 (assign -> MINUSMINUS lhs .)
    NEQUALS         reduce using rule 102 (assign -> MINUSMINUS lhs .)
    LESS            reduce using rule 102 (assign -> MINUSMINUS lhs .)
    GREATER         reduce using rule 102 (assign -> MINUSMINUS lhs .)
    LEQUALS         reduce using rule 102 (assign -> MINUSMINUS lhs .)
    GEQUALS         reduce using rule 102 (assign -> MINUSMINUS lhs .)
    COMMA           reduce using rule 102 (assign -> MINUSMINUS lhs .)
    PERIOD          reduce using rule 71 (primary -> lhs .)


state 134

    (80) method_invocation -> field_access LPAREN . arguments RPAREN
    (73) arguments -> . expr many_comma_expr
    (74) arguments -> . empty
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (105) empty -> .
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    RPAREN          reduce using rule 105 (empty -> .)
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    field_access                   shift and go to state 120
    arguments                      shift and go to state 160
    expr                           shift and go to state 161
    empty                          shift and go to state 162
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118

state 135

    (78) field_access -> primary PERIOD . ID

    ID              shift and go to state 163


state 136

    (70) primary -> NEW ID . LPAREN arguments RPAREN

    LPAREN          shift and go to state 164


state 137

    (41) stmt -> IF LPAREN expr . RPAREN stmt
    (42) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          shift and go to state 165
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150


state 138

    (69) primary -> LPAREN expr RPAREN .

    PERIOD          reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    EEQUALS         reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    NEQUALS         reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    LESS            reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    LEQUALS         reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    GEQUALS         reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 69 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 69 (primary -> LPAREN expr RPAREN .)


state 139

    (83) expr -> expr PLUS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 166
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 140

    (84) expr -> expr MINUS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 167
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 141

    (85) expr -> expr TIMES . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 168
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 142

    (86) expr -> expr DIVIDE . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 169
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 143

    (87) expr -> expr AND . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 170
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 144

    (88) expr -> expr OR . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 171
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 145

    (89) expr -> expr EEQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 172
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 146

    (90) expr -> expr NEQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 173
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 147

    (91) expr -> expr LESS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 174
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 148

    (92) expr -> expr GREATER . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 175
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 149

    (93) expr -> expr LEQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 176
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 150

    (94) expr -> expr GEQUALS . expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 177
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 151

    (95) expr -> PLUS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 95 (expr -> PLUS expr .)
    PLUS            reduce using rule 95 (expr -> PLUS expr .)
    MINUS           reduce using rule 95 (expr -> PLUS expr .)
    TIMES           reduce using rule 95 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 95 (expr -> PLUS expr .)
    AND             reduce using rule 95 (expr -> PLUS expr .)
    OR              reduce using rule 95 (expr -> PLUS expr .)
    EEQUALS         reduce using rule 95 (expr -> PLUS expr .)
    NEQUALS         reduce using rule 95 (expr -> PLUS expr .)
    LESS            reduce using rule 95 (expr -> PLUS expr .)
    GREATER         reduce using rule 95 (expr -> PLUS expr .)
    LEQUALS         reduce using rule 95 (expr -> PLUS expr .)
    GEQUALS         reduce using rule 95 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 95 (expr -> PLUS expr .)
    COMMA           reduce using rule 95 (expr -> PLUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! TIMES           [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 152

    (96) expr -> MINUS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 96 (expr -> MINUS expr .)
    PLUS            reduce using rule 96 (expr -> MINUS expr .)
    MINUS           reduce using rule 96 (expr -> MINUS expr .)
    TIMES           reduce using rule 96 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 96 (expr -> MINUS expr .)
    AND             reduce using rule 96 (expr -> MINUS expr .)
    OR              reduce using rule 96 (expr -> MINUS expr .)
    EEQUALS         reduce using rule 96 (expr -> MINUS expr .)
    NEQUALS         reduce using rule 96 (expr -> MINUS expr .)
    LESS            reduce using rule 96 (expr -> MINUS expr .)
    GREATER         reduce using rule 96 (expr -> MINUS expr .)
    LEQUALS         reduce using rule 96 (expr -> MINUS expr .)
    GEQUALS         reduce using rule 96 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 96 (expr -> MINUS expr .)
    COMMA           reduce using rule 96 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! TIMES           [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 153

    (97) expr -> NOT expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 97 (expr -> NOT expr .)
    PLUS            reduce using rule 97 (expr -> NOT expr .)
    MINUS           reduce using rule 97 (expr -> NOT expr .)
    TIMES           reduce using rule 97 (expr -> NOT expr .)
    DIVIDE          reduce using rule 97 (expr -> NOT expr .)
    AND             reduce using rule 97 (expr -> NOT expr .)
    OR              reduce using rule 97 (expr -> NOT expr .)
    EEQUALS         reduce using rule 97 (expr -> NOT expr .)
    NEQUALS         reduce using rule 97 (expr -> NOT expr .)
    LESS            reduce using rule 97 (expr -> NOT expr .)
    GREATER         reduce using rule 97 (expr -> NOT expr .)
    LEQUALS         reduce using rule 97 (expr -> NOT expr .)
    GEQUALS         reduce using rule 97 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 97 (expr -> NOT expr .)
    COMMA           reduce using rule 97 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! TIMES           [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 154

    (43) stmt -> WHILE LPAREN expr . RPAREN stmt
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          shift and go to state 178
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150


state 155

    (44) stmt -> FOR LPAREN for_cond1 . SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt

    SEMICOLON       shift and go to state 179


state 156

    (52) for_cond1 -> stmt_expr .

    SEMICOLON       reduce using rule 52 (for_cond1 -> stmt_expr .)


state 157

    (53) for_cond1 -> empty .

    SEMICOLON       reduce using rule 53 (for_cond1 -> empty .)


state 158

    (45) stmt -> RETURN return_val SEMICOLON .

    IF              reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    LCURLY          reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    PLUSPLUS        reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    MINUSMINUS      reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    INT             reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    VOID            reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    ID              reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    INT_CONST       reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    FLOAT_CONST     reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    STRING_CONST    reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    RCURLY          reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> RETURN return_val SEMICOLON .)


state 159

    (98) assign -> lhs EQUALS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    SEMICOLON       reduce using rule 98 (assign -> lhs EQUALS expr .)
    RPAREN          reduce using rule 98 (assign -> lhs EQUALS expr .)
    COMMA           reduce using rule 98 (assign -> lhs EQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150

  ! PLUS            [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! MINUS           [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! TIMES           [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! AND             [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! OR              [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! EEQUALS         [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! NEQUALS         [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! LESS            [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! GREATER         [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! LEQUALS         [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]
  ! GEQUALS         [ reduce using rule 98 (assign -> lhs EQUALS expr .) ]


state 160

    (80) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 180


state 161

    (73) arguments -> expr . many_comma_expr
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr
    (75) many_comma_expr -> . COMMA expr many_comma_expr
    (76) many_comma_expr -> . empty
    (105) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150
    COMMA           shift and go to state 182
    RPAREN          reduce using rule 105 (empty -> .)

    many_comma_expr                shift and go to state 181
    empty                          shift and go to state 183

state 162

    (74) arguments -> empty .

    RPAREN          reduce using rule 74 (arguments -> empty .)


state 163

    (78) field_access -> primary PERIOD ID .

    LPAREN          reduce using rule 78 (field_access -> primary PERIOD ID .)
    EQUALS          reduce using rule 78 (field_access -> primary PERIOD ID .)
    PLUSPLUS        reduce using rule 78 (field_access -> primary PERIOD ID .)
    MINUSMINUS      reduce using rule 78 (field_access -> primary PERIOD ID .)
    PERIOD          reduce using rule 78 (field_access -> primary PERIOD ID .)
    RPAREN          reduce using rule 78 (field_access -> primary PERIOD ID .)
    PLUS            reduce using rule 78 (field_access -> primary PERIOD ID .)
    MINUS           reduce using rule 78 (field_access -> primary PERIOD ID .)
    TIMES           reduce using rule 78 (field_access -> primary PERIOD ID .)
    DIVIDE          reduce using rule 78 (field_access -> primary PERIOD ID .)
    AND             reduce using rule 78 (field_access -> primary PERIOD ID .)
    OR              reduce using rule 78 (field_access -> primary PERIOD ID .)
    EEQUALS         reduce using rule 78 (field_access -> primary PERIOD ID .)
    NEQUALS         reduce using rule 78 (field_access -> primary PERIOD ID .)
    LESS            reduce using rule 78 (field_access -> primary PERIOD ID .)
    GREATER         reduce using rule 78 (field_access -> primary PERIOD ID .)
    LEQUALS         reduce using rule 78 (field_access -> primary PERIOD ID .)
    GEQUALS         reduce using rule 78 (field_access -> primary PERIOD ID .)
    SEMICOLON       reduce using rule 78 (field_access -> primary PERIOD ID .)
    COMMA           reduce using rule 78 (field_access -> primary PERIOD ID .)


state 164

    (70) primary -> NEW ID LPAREN . arguments RPAREN
    (73) arguments -> . expr many_comma_expr
    (74) arguments -> . empty
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (105) empty -> .
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    RPAREN          reduce using rule 105 (empty -> .)
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    arguments                      shift and go to state 184
    expr                           shift and go to state 161
    empty                          shift and go to state 162
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 165

    (41) stmt -> IF LPAREN expr RPAREN . stmt
    (42) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    stmt                           shift and go to state 185
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 166

    (83) expr -> expr PLUS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 83 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 83 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 83 (expr -> expr PLUS expr .)
    AND             reduce using rule 83 (expr -> expr PLUS expr .)
    OR              reduce using rule 83 (expr -> expr PLUS expr .)
    EEQUALS         reduce using rule 83 (expr -> expr PLUS expr .)
    NEQUALS         reduce using rule 83 (expr -> expr PLUS expr .)
    LESS            reduce using rule 83 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 83 (expr -> expr PLUS expr .)
    LEQUALS         reduce using rule 83 (expr -> expr PLUS expr .)
    GEQUALS         reduce using rule 83 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 83 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 83 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! TIMES           [ reduce using rule 83 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 83 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 167

    (84) expr -> expr MINUS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 84 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 84 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 84 (expr -> expr MINUS expr .)
    AND             reduce using rule 84 (expr -> expr MINUS expr .)
    OR              reduce using rule 84 (expr -> expr MINUS expr .)
    EEQUALS         reduce using rule 84 (expr -> expr MINUS expr .)
    NEQUALS         reduce using rule 84 (expr -> expr MINUS expr .)
    LESS            reduce using rule 84 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 84 (expr -> expr MINUS expr .)
    LEQUALS         reduce using rule 84 (expr -> expr MINUS expr .)
    GEQUALS         reduce using rule 84 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 84 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 84 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! TIMES           [ reduce using rule 84 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 84 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 168

    (85) expr -> expr TIMES expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 85 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 85 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 85 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 85 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 85 (expr -> expr TIMES expr .)
    AND             reduce using rule 85 (expr -> expr TIMES expr .)
    OR              reduce using rule 85 (expr -> expr TIMES expr .)
    EEQUALS         reduce using rule 85 (expr -> expr TIMES expr .)
    NEQUALS         reduce using rule 85 (expr -> expr TIMES expr .)
    LESS            reduce using rule 85 (expr -> expr TIMES expr .)
    GREATER         reduce using rule 85 (expr -> expr TIMES expr .)
    LEQUALS         reduce using rule 85 (expr -> expr TIMES expr .)
    GEQUALS         reduce using rule 85 (expr -> expr TIMES expr .)
    SEMICOLON       reduce using rule 85 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 85 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! TIMES           [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 169

    (86) expr -> expr DIVIDE expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 86 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 86 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 86 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 86 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 86 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 86 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 86 (expr -> expr DIVIDE expr .)
    EEQUALS         reduce using rule 86 (expr -> expr DIVIDE expr .)
    NEQUALS         reduce using rule 86 (expr -> expr DIVIDE expr .)
    LESS            reduce using rule 86 (expr -> expr DIVIDE expr .)
    GREATER         reduce using rule 86 (expr -> expr DIVIDE expr .)
    LEQUALS         reduce using rule 86 (expr -> expr DIVIDE expr .)
    GEQUALS         reduce using rule 86 (expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 86 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 86 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! TIMES           [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 170

    (87) expr -> expr AND expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 87 (expr -> expr AND expr .)
    AND             reduce using rule 87 (expr -> expr AND expr .)
    OR              reduce using rule 87 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 87 (expr -> expr AND expr .)
    COMMA           reduce using rule 87 (expr -> expr AND expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150

  ! PLUS            [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! EEQUALS         [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! NEQUALS         [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! LESS            [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! GREATER         [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! LEQUALS         [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! GEQUALS         [ reduce using rule 87 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]


state 171

    (88) expr -> expr OR expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 88 (expr -> expr OR expr .)
    OR              reduce using rule 88 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 88 (expr -> expr OR expr .)
    COMMA           reduce using rule 88 (expr -> expr OR expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150

  ! PLUS            [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! EEQUALS         [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! NEQUALS         [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! LESS            [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! GREATER         [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! LEQUALS         [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! GEQUALS         [ reduce using rule 88 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 144 ]


state 172

    (89) expr -> expr EEQUALS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 89 (expr -> expr EEQUALS expr .)
    AND             reduce using rule 89 (expr -> expr EEQUALS expr .)
    OR              reduce using rule 89 (expr -> expr EEQUALS expr .)
    EEQUALS         reduce using rule 89 (expr -> expr EEQUALS expr .)
    NEQUALS         reduce using rule 89 (expr -> expr EEQUALS expr .)
    SEMICOLON       reduce using rule 89 (expr -> expr EEQUALS expr .)
    COMMA           reduce using rule 89 (expr -> expr EEQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150

  ! PLUS            [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! MINUS           [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! TIMES           [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! LESS            [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! GREATER         [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! LEQUALS         [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! GEQUALS         [ reduce using rule 89 (expr -> expr EEQUALS expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]


state 173

    (90) expr -> expr NEQUALS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 90 (expr -> expr NEQUALS expr .)
    AND             reduce using rule 90 (expr -> expr NEQUALS expr .)
    OR              reduce using rule 90 (expr -> expr NEQUALS expr .)
    EEQUALS         reduce using rule 90 (expr -> expr NEQUALS expr .)
    NEQUALS         reduce using rule 90 (expr -> expr NEQUALS expr .)
    SEMICOLON       reduce using rule 90 (expr -> expr NEQUALS expr .)
    COMMA           reduce using rule 90 (expr -> expr NEQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150

  ! PLUS            [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! MINUS           [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! TIMES           [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! LESS            [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! GREATER         [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! LEQUALS         [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! GEQUALS         [ reduce using rule 90 (expr -> expr NEQUALS expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]


state 174

    (91) expr -> expr LESS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 91 (expr -> expr LESS expr .)
    AND             reduce using rule 91 (expr -> expr LESS expr .)
    OR              reduce using rule 91 (expr -> expr LESS expr .)
    EEQUALS         reduce using rule 91 (expr -> expr LESS expr .)
    NEQUALS         reduce using rule 91 (expr -> expr LESS expr .)
    LESS            reduce using rule 91 (expr -> expr LESS expr .)
    GREATER         reduce using rule 91 (expr -> expr LESS expr .)
    LEQUALS         reduce using rule 91 (expr -> expr LESS expr .)
    GEQUALS         reduce using rule 91 (expr -> expr LESS expr .)
    SEMICOLON       reduce using rule 91 (expr -> expr LESS expr .)
    COMMA           reduce using rule 91 (expr -> expr LESS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 91 (expr -> expr LESS expr .) ]
  ! MINUS           [ reduce using rule 91 (expr -> expr LESS expr .) ]
  ! TIMES           [ reduce using rule 91 (expr -> expr LESS expr .) ]
  ! DIVIDE          [ reduce using rule 91 (expr -> expr LESS expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 175

    (92) expr -> expr GREATER expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 92 (expr -> expr GREATER expr .)
    AND             reduce using rule 92 (expr -> expr GREATER expr .)
    OR              reduce using rule 92 (expr -> expr GREATER expr .)
    EEQUALS         reduce using rule 92 (expr -> expr GREATER expr .)
    NEQUALS         reduce using rule 92 (expr -> expr GREATER expr .)
    LESS            reduce using rule 92 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 92 (expr -> expr GREATER expr .)
    LEQUALS         reduce using rule 92 (expr -> expr GREATER expr .)
    GEQUALS         reduce using rule 92 (expr -> expr GREATER expr .)
    SEMICOLON       reduce using rule 92 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 92 (expr -> expr GREATER expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 92 (expr -> expr GREATER expr .) ]
  ! MINUS           [ reduce using rule 92 (expr -> expr GREATER expr .) ]
  ! TIMES           [ reduce using rule 92 (expr -> expr GREATER expr .) ]
  ! DIVIDE          [ reduce using rule 92 (expr -> expr GREATER expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 176

    (93) expr -> expr LEQUALS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 93 (expr -> expr LEQUALS expr .)
    AND             reduce using rule 93 (expr -> expr LEQUALS expr .)
    OR              reduce using rule 93 (expr -> expr LEQUALS expr .)
    EEQUALS         reduce using rule 93 (expr -> expr LEQUALS expr .)
    NEQUALS         reduce using rule 93 (expr -> expr LEQUALS expr .)
    LESS            reduce using rule 93 (expr -> expr LEQUALS expr .)
    GREATER         reduce using rule 93 (expr -> expr LEQUALS expr .)
    LEQUALS         reduce using rule 93 (expr -> expr LEQUALS expr .)
    GEQUALS         reduce using rule 93 (expr -> expr LEQUALS expr .)
    SEMICOLON       reduce using rule 93 (expr -> expr LEQUALS expr .)
    COMMA           reduce using rule 93 (expr -> expr LEQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 93 (expr -> expr LEQUALS expr .) ]
  ! MINUS           [ reduce using rule 93 (expr -> expr LEQUALS expr .) ]
  ! TIMES           [ reduce using rule 93 (expr -> expr LEQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 93 (expr -> expr LEQUALS expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 177

    (94) expr -> expr GEQUALS expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    RPAREN          reduce using rule 94 (expr -> expr GEQUALS expr .)
    AND             reduce using rule 94 (expr -> expr GEQUALS expr .)
    OR              reduce using rule 94 (expr -> expr GEQUALS expr .)
    EEQUALS         reduce using rule 94 (expr -> expr GEQUALS expr .)
    NEQUALS         reduce using rule 94 (expr -> expr GEQUALS expr .)
    LESS            reduce using rule 94 (expr -> expr GEQUALS expr .)
    GREATER         reduce using rule 94 (expr -> expr GEQUALS expr .)
    LEQUALS         reduce using rule 94 (expr -> expr GEQUALS expr .)
    GEQUALS         reduce using rule 94 (expr -> expr GEQUALS expr .)
    SEMICOLON       reduce using rule 94 (expr -> expr GEQUALS expr .)
    COMMA           reduce using rule 94 (expr -> expr GEQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 94 (expr -> expr GEQUALS expr .) ]
  ! MINUS           [ reduce using rule 94 (expr -> expr GEQUALS expr .) ]
  ! TIMES           [ reduce using rule 94 (expr -> expr GEQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 94 (expr -> expr GEQUALS expr .) ]
  ! AND             [ shift and go to state 143 ]
  ! OR              [ shift and go to state 144 ]
  ! EEQUALS         [ shift and go to state 145 ]
  ! NEQUALS         [ shift and go to state 146 ]
  ! LESS            [ shift and go to state 147 ]
  ! GREATER         [ shift and go to state 148 ]
  ! LEQUALS         [ shift and go to state 149 ]
  ! GEQUALS         [ shift and go to state 150 ]


state 178

    (43) stmt -> WHILE LPAREN expr RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    stmt                           shift and go to state 186
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 179

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON . for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (54) for_cond2 -> . expr
    (55) for_cond2 -> . empty
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (105) empty -> .
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    SEMICOLON       reduce using rule 105 (empty -> .)
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    for_cond2                      shift and go to state 187
    expr                           shift and go to state 188
    empty                          shift and go to state 189
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 180

    (80) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PERIOD          reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EEQUALS         reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NEQUALS         reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LEQUALS         reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GEQUALS         reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 80 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 181

    (73) arguments -> expr many_comma_expr .

    RPAREN          reduce using rule 73 (arguments -> expr many_comma_expr .)


state 182

    (75) many_comma_expr -> COMMA . expr many_comma_expr
    (81) expr -> . primary
    (82) expr -> . assign
    (83) expr -> . expr PLUS expr
    (84) expr -> . expr MINUS expr
    (85) expr -> . expr TIMES expr
    (86) expr -> . expr DIVIDE expr
    (87) expr -> . expr AND expr
    (88) expr -> . expr OR expr
    (89) expr -> . expr EEQUALS expr
    (90) expr -> . expr NEQUALS expr
    (91) expr -> . expr LESS expr
    (92) expr -> . expr GREATER expr
    (93) expr -> . expr LEQUALS expr
    (94) expr -> . expr GEQUALS expr
    (95) expr -> . PLUS expr
    (96) expr -> . MINUS expr
    (97) expr -> . NOT expr
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE
    (77) lhs -> . field_access
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    PLUS            shift and go to state 113
    MINUS           shift and go to state 114
    NOT             shift and go to state 115
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 116

    expr                           shift and go to state 190
    primary                        shift and go to state 111
    assign                         shift and go to state 112
    literal                        shift and go to state 96
    lhs                            shift and go to state 117
    method_invocation              shift and go to state 118
    field_access                   shift and go to state 120

state 183

    (76) many_comma_expr -> empty .

    RPAREN          reduce using rule 76 (many_comma_expr -> empty .)


state 184

    (70) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 191


state 185

    (41) stmt -> IF LPAREN expr RPAREN stmt .
    (42) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    VOID            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    RCURLY          reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 192

  ! ELSE            [ reduce using rule 41 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 186

    (43) stmt -> WHILE LPAREN expr RPAREN stmt .

    IF              reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LCURLY          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    VOID            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RCURLY          reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 187

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 . SEMICOLON for_cond3 RPAREN stmt

    SEMICOLON       shift and go to state 193


state 188

    (54) for_cond2 -> expr .
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr

    SEMICOLON       reduce using rule 54 (for_cond2 -> expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150


state 189

    (55) for_cond2 -> empty .

    SEMICOLON       reduce using rule 55 (for_cond2 -> empty .)


state 190

    (75) many_comma_expr -> COMMA expr . many_comma_expr
    (83) expr -> expr . PLUS expr
    (84) expr -> expr . MINUS expr
    (85) expr -> expr . TIMES expr
    (86) expr -> expr . DIVIDE expr
    (87) expr -> expr . AND expr
    (88) expr -> expr . OR expr
    (89) expr -> expr . EEQUALS expr
    (90) expr -> expr . NEQUALS expr
    (91) expr -> expr . LESS expr
    (92) expr -> expr . GREATER expr
    (93) expr -> expr . LEQUALS expr
    (94) expr -> expr . GEQUALS expr
    (75) many_comma_expr -> . COMMA expr many_comma_expr
    (76) many_comma_expr -> . empty
    (105) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EEQUALS         shift and go to state 145
    NEQUALS         shift and go to state 146
    LESS            shift and go to state 147
    GREATER         shift and go to state 148
    LEQUALS         shift and go to state 149
    GEQUALS         shift and go to state 150
    COMMA           shift and go to state 182
    RPAREN          reduce using rule 105 (empty -> .)

    many_comma_expr                shift and go to state 194
    empty                          shift and go to state 183

state 191

    (70) primary -> NEW ID LPAREN arguments RPAREN .

    PERIOD          reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    EEQUALS         reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    NEQUALS         reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    LEQUALS         reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    GEQUALS         reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 70 (primary -> NEW ID LPAREN arguments RPAREN .)


state 192

    (42) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    stmt                           shift and go to state 195
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 193

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON . for_cond3 RPAREN stmt
    (56) for_cond3 -> . stmt_expr
    (57) for_cond3 -> . empty
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (105) empty -> .
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    RPAREN          reduce using rule 105 (empty -> .)
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    ID              shift and go to state 116
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    NULL            shift and go to state 119
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    for_cond3                      shift and go to state 196
    stmt_expr                      shift and go to state 197
    empty                          shift and go to state 198
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 194

    (75) many_comma_expr -> COMMA expr many_comma_expr .

    RPAREN          reduce using rule 75 (many_comma_expr -> COMMA expr many_comma_expr .)


state 195

    (42) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    IF              reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    VOID            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT_CONST       reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING_CONST    reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RCURLY          reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 42 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 196

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 . RPAREN stmt

    RPAREN          shift and go to state 199


state 197

    (56) for_cond3 -> stmt_expr .

    RPAREN          reduce using rule 56 (for_cond3 -> stmt_expr .)


state 198

    (57) for_cond3 -> empty .

    RPAREN          reduce using rule 57 (for_cond3 -> empty .)


state 199

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN . stmt
    (41) stmt -> . IF LPAREN expr RPAREN stmt
    (42) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (43) stmt -> . WHILE LPAREN expr RPAREN stmt
    (44) stmt -> . FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt
    (45) stmt -> . RETURN return_val SEMICOLON
    (46) stmt -> . stmt_expr SEMICOLON
    (47) stmt -> . BREAK SEMICOLON
    (48) stmt -> . CONTINUE SEMICOLON
    (49) stmt -> . block
    (50) stmt -> . var_decl
    (51) stmt -> . SEMICOLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (38) block -> . LCURLY many_stmts RCURLY
    (19) var_decl -> . type variables SEMICOLON
    (98) assign -> . lhs EQUALS expr
    (99) assign -> . lhs PLUSPLUS
    (100) assign -> . PLUSPLUS lhs
    (101) assign -> . lhs MINUSMINUS
    (102) assign -> . MINUSMINUS lhs
    (80) method_invocation -> . field_access LPAREN arguments RPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . VOID
    (24) type -> . NULL
    (25) type -> . ID
    (77) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (66) primary -> . literal
    (67) primary -> . THIS
    (68) primary -> . SUPER
    (69) primary -> . LPAREN expr RPAREN
    (70) primary -> . NEW ID LPAREN arguments RPAREN
    (71) primary -> . lhs
    (72) primary -> . method_invocation
    (60) literal -> . INT_CONST
    (61) literal -> . FLOAT_CONST
    (62) literal -> . STRING_CONST
    (63) literal -> . NULL
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IF              shift and go to state 75
    WHILE           shift and go to state 77
    FOR             shift and go to state 78
    RETURN          shift and go to state 80
    BREAK           shift and go to state 82
    CONTINUE        shift and go to state 83
    SEMICOLON       shift and go to state 79
    LCURLY          shift and go to state 68
    PLUSPLUS        shift and go to state 90
    MINUSMINUS      shift and go to state 91
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 54
    NULL            shift and go to state 93
    ID              shift and go to state 94
    THIS            shift and go to state 97
    SUPER           shift and go to state 98
    LPAREN          shift and go to state 76
    NEW             shift and go to state 99
    INT_CONST       shift and go to state 100
    FLOAT_CONST     shift and go to state 101
    STRING_CONST    shift and go to state 102
    TRUE            shift and go to state 103
    FALSE           shift and go to state 104

    stmt                           shift and go to state 200
    stmt_expr                      shift and go to state 81
    block                          shift and go to state 84
    var_decl                       shift and go to state 85
    assign                         shift and go to state 86
    method_invocation              shift and go to state 87
    type                           shift and go to state 88
    lhs                            shift and go to state 89
    field_access                   shift and go to state 92
    primary                        shift and go to state 95
    literal                        shift and go to state 96

state 200

    (44) stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .

    IF              reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    WHILE           reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    FOR             reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    RETURN          reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    BREAK           reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    CONTINUE        reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    SEMICOLON       reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    LCURLY          reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    PLUSPLUS        reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    MINUSMINUS      reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    INT             reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    FLOAT           reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    BOOLEAN         reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    VOID            reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    NULL            reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    ID              reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    THIS            reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    SUPER           reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    LPAREN          reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    NEW             reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    INT_CONST       reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    FLOAT_CONST     reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    STRING_CONST    reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    TRUE            reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    FALSE           reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    RCURLY          reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)
    ELSE            reduce using rule 44 (stmt -> FOR LPAREN for_cond1 SEMICOLON for_cond2 SEMICOLON for_cond3 RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 185 resolved as shift
